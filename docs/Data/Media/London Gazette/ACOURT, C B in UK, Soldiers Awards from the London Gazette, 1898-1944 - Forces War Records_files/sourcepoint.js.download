(()=>{"use strict";var __webpack_modules__={24812:()=>{eval('\n;// CONCATENATED MODULE: ./src/ts/shared/enums/cookies.enum.ts\nvar COOKIES;\n(function (COOKIES) {\n    COOKIES["SESSION"] = "sess";\n    COOKIES["CHANGE_PWD"] = "f3_change_pwd";\n    COOKIES["IID"] = "lastIid";\n    COOKIES["SID"] = "lastSid";\n    COOKIES["XID"] = "lastXid";\n    COOKIES["OID"] = "lastOid";\n    COOKIES["GCLID"] = "gclid";\n    COOKIES["FREE_ACCESS"] = "fat";\n    COOKIES["PROQUEST"] = "pqd";\n    COOKIES["PROQUEST_LOGIN"] = "pqu";\n    COOKIES["PQ_SEARCH"] = "pqSearchId";\n    COOKIES["ADOPTION_VALUE"] = "f3av";\n    COOKIES["LAST_LOGIN"] = "f3ll";\n    COOKIES["DENY_PUB"] = "f3_deny_pub";\n    COOKIES["PARTNER_TOKEN"] = "f3_partner_token";\n    COOKIES["DENY_URL"] = "f3_deny_url";\n    COOKIES["GRAPHIC_KEY"] = "f3_show_graphic_images";\n    COOKIES["COMMISSION_JUNCTION"] = "cj_affiliate_id";\n    COOKIES["LINK_SHARE"] = "siteID";\n    COOKIES["CONSENT_SETTINGS"] = "f3_consent_settings";\n    COOKIES["FWR_SESSION"] = "FwrUd";\n    COOKIES["FWR_REDIRECT"] = "f3_FwrRedirect";\n    COOKIES["LANGUAGE"] = "f3_language";\n    COOKIES["CHOOSE_DOMAIN"] = "f3_choose_domain";\n    COOKIES["CAPTCHA"] = "f3_captcha";\n    /* TESTING */\n    COOKIES["TESTING"] = "f3_testing";\n    COOKIES["USER_EXPIRATION"] = "f3_user_expiration";\n    COOKIES["INST_EXPIRATION"] = "f3_inst_expiration";\n    COOKIES["PROVIDER"] = "f3_testing_provider";\n    COOKIES["TEST_IP"] = "f3_testing_ip";\n    COOKIES["TEST_COUNTRY_CODE"] = "f3_testing_country";\n    COOKIES["CAMPAIGN_TEST"] = "camp_tt";\n})(COOKIES || (COOKIES = {}));\nvar isTrustedCookie = function (key) {\n    switch (key) {\n        case COOKIES.SESSION:\n        case COOKIES.CHANGE_PWD:\n        case COOKIES.IID:\n        case COOKIES.SID:\n        case COOKIES.XID:\n        case COOKIES.OID:\n        case COOKIES.GCLID:\n        case COOKIES.FREE_ACCESS:\n        case COOKIES.PROQUEST:\n        case COOKIES.PROQUEST_LOGIN:\n        case COOKIES.ADOPTION_VALUE:\n        case COOKIES.LAST_LOGIN:\n        case COOKIES.DENY_PUB:\n        case COOKIES.CAPTCHA:\n        case COOKIES.LANGUAGE:\n        case COOKIES.CHOOSE_DOMAIN:\n        case COOKIES.CONSENT_SETTINGS:\n        /* TESTING */\n        case COOKIES.TESTING:\n        case COOKIES.USER_EXPIRATION:\n        case COOKIES.INST_EXPIRATION:\n        case COOKIES.TEST_IP:\n        case COOKIES.TEST_COUNTRY_CODE:\n        case COOKIES.CAMPAIGN_TEST:\n            return true;\n        default:\n            return false;\n    }\n};\nvar isNecessaryCookie = function (name) {\n    switch (name) {\n        case COOKIES.CHANGE_PWD:\n        case COOKIES.PARTNER_TOKEN:\n        case COOKIES.LAST_LOGIN:\n        case COOKIES.PROQUEST:\n        case COOKIES.PROQUEST_LOGIN:\n        case COOKIES.PQ_SEARCH:\n        case COOKIES.SESSION:\n        case COOKIES.LANGUAGE:\n        case COOKIES.CHOOSE_DOMAIN:\n        case COOKIES.CONSENT_SETTINGS:\n            return true;\n        default:\n            return false;\n    }\n};\nvar CONSENT_COOKIES = [COOKIES.CONSENT_SETTINGS, \'_sp_enable_dfp_personalized_ads\', \'consentUUID\', \'euconsent-v2\', \'ccpaUUID\', \'dnsDisplayed\', \'ccpaApplies\', \'signedLspa\', \'_sp_su\', \'consentDate\'];\n\n;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ts/shared/lib/clientCookies.ts\n\n\n/**\n * set a cookie, with convenient path/domain options\n *\n * WARNING: multiple cookies can exist at different paths and domains.\n * If you create a cookie with the same name and path as another, both will exist\n * simultaneously, and the one with the more specific path/domain will override the other.\n */\nfunction setCookie(name, value, opts) {\n    if (value === void 0) { value = \'\'; }\n    if (opts === void 0) { opts = {}; }\n    if (allowedToSetCookie(name)) {\n        var params = [];\n        /*\n         * note: this is not universal!  this is how fold3 sets its cookies.\n         * If this code gets borrowed for another site, it may need be changed.\n         */\n        var cookieDomain = \'.\' + location.hostname.split(\'.\').slice(-2)\n            .join(\'.\');\n        if (!opts.raw)\n            value = encodeURIComponent(value);\n        params.push(name + \'=\' + (value || \'\'));\n        if (opts.expires) {\n            var date = new Date(opts.expires < 0 ? -1 : Date.now() + opts.expires * 1000);\n            params.push(\'expires=\' + date.toUTCString());\n        }\n        // allow unsetting (as well as changing) domain using opts.domain\n        var domain = cookieDomain;\n        if (typeof opts.domain !== \'undefined\') {\n            domain = opts.domain;\n        }\n        if (domain) {\n            params.push(\'domain=\' + domain);\n        }\n        params.push(\'path=\' + (opts.path || \'/\'));\n        document.cookie = params.join(\'; \');\n    }\n}\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \'\\\\$&\');\n}\n/**\n * get a cookie\n *\n * WARNING: multiple cookies can exist at different paths and domains.\n * Only the most specific will be visible\n */\nfunction getCookie(name, raw) {\n    if (raw === void 0) { raw = false; }\n    var match = document.cookie.match(new RegExp(\'(^| )\' + escapeRegExp(name) + \'=([^;]+)\'));\n    var cookie = match && match[2];\n    if (cookie && !raw)\n        cookie = decodeURIComponent(cookie);\n    return cookie;\n}\n/**\n * delete a cookie, with convenient path/domain defaults\n *\n * WARNING: This will only work if the path and domain match the set cookie!\n */\nfunction deleteCookie(name, opts) {\n    if (opts === void 0) { opts = {}; }\n    setCookie(name, \'\', __assign({ expires: -1 }, opts));\n}\nvar allowedToSetCookie = function (name) {\n    if (isNecessaryCookie(name)) {\n        return true;\n    }\n    try {\n        var consentSettings = JSON.parse(getCookie(COOKIES.CONSENT_SETTINGS));\n        if (consentSettings.gdpr.applies === true) {\n            if (consentSettings.gdpr.source === \'sourcepoint\') {\n                return consentSettings.gdpr.consentedVendors.includes(\'Ancestry\');\n            }\n            else {\n                return false; // Be on the safe side if sourcepoint hasn\'t verified consent and gdpr applies\n            }\n        }\n        else {\n            return true;\n        }\n    }\n    catch (e) {\n        console.error(e);\n        return true;\n    }\n};\n\n;// CONCATENATED MODULE: ./src/ts/shared/lib/cookie-consent/sourcepoint.ts\n/* Brief intro to all of this confusing stuff:\n *\n * This file is a wrapper for Sourcepoint\'s consent management platform (CMP).\n * Sourcepoint is a third-party service that provides a way to manage consent for cookies and tracking.\n * The CMP is used to manage consent for cookies and tracking.\n * The CMP is responsible for displaying a consent dialog to the user. The user can then choose to accept or reject cookies and tracking. The CMP then sets a cookie with the user\'s consent settings.\n * Anything in this script referring to usnat is for the US National Privacy Law, which is a different set of laws than the GDPR.\n * In order to adhere to the usnat, we are using gpp (Global Privacy Platform) to manage consent for the US National Privacy Law.\n * Anything in this script that is referring to tcf is for adhering to the GDPR laws for Europe.\n *\n * We are calling _tcfapi(\'addEventListener\') to know whether gdpr applies for this user.\n * We are calling _tcfapi(\'getCustomVendorConsents\') to get the user\'s consent settings for the GDPR.\n*/\n\n\n(function () {\n    function sendNonGDPRPageviewEvent() {\n        try {\n            window.dataLayer = window.dataLayer || [];\n            dataLayer.push({\n                event: \'non_gdpr_pageview\',\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    function showGDPRPrivacyLink() {\n        try {\n            document.getElementById(\'gdpr_link_display\').style.display = \'inline-block\';\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    function consentCheck(eventType) {\n        var _a;\n        var settings = {\n            gdpr: {},\n        };\n        if (eventType === \'gdpr\') {\n            try {\n                settings = JSON.parse(getCookie(COOKIES.CONSENT_SETTINGS));\n            }\n            catch (e) {\n                console.error(e);\n            }\n            if (((_a = settings === null || settings === void 0 ? void 0 : settings.gdpr) === null || _a === void 0 ? void 0 : _a.source) === \'sourcepoint\') {\n                /* We know that sourcepoint has told us whether gdpr applies for this user. Nothing left to do */\n            }\n            else {\n                __tcfapi(\'addEventListener\', 2, function (tcData, success) {\n                    if (success) {\n                        settings.gdpr.applies = tcData.gdprApplies;\n                        settings.gdpr.source = \'sourcepoint\'; // sourcepoint has told us that gdpr applies for this user\n                        if (settings.gdpr.applies) {\n                            __tcfapi(\'getCustomVendorConsents\', 2, function (vendorConsents, success) {\n                                if (success) {\n                                    var vendors = vendorConsents.consentedVendors\n                                        .map(function (x) { return x.name; })\n                                        .filter(function (x) { return x === \'Ancestry\'; }); // For now, we are only interested in Ancestry. Add more vendors as needed.\n                                    settings.gdpr.consentedVendors = vendors;\n                                }\n                                else {\n                                    console.error(\'getCustomVendorConsents failed.\');\n                                }\n                            });\n                        }\n                    }\n                    else {\n                        console.error(\'failed to get tcData\');\n                    }\n                    setCookie(COOKIES.CONSENT_SETTINGS, JSON.stringify(settings));\n                });\n            }\n        }\n        if (settings.gdpr.applies) {\n            showGDPRPrivacyLink();\n        }\n        else {\n            sendNonGDPRPageviewEvent();\n        }\n    }\n    window._sp_queue = [];\n    window._sp_ = {\n        config: {\n            accountId: 1726,\n            propertyHref: window.location.origin,\n            baseEndpoint: \'https://cdn.privacy-mgmt.com\',\n            gdpr: {},\n            usnat: {\n                includesUspApi: true,\n            },\n            consentLanguage: window.F3.page.language,\n            custom: {},\n            events: {\n                onMessageChoiceSelect: function () {\n                    // console.log(\'[event] onMessageChoiceSelect\', arguments);\n                    deleteCookie(COOKIES.CONSENT_SETTINGS);\n                },\n                onMessageReady: function () {\n                    // console.log(\'[event] onMessageReady\', arguments);\n                },\n                onMessageChoiceError: function () {\n                    // console.log(\'[event] onMessageChoiceError\', arguments);\n                },\n                onPrivacyManagerAction: function () {\n                    // console.log(\'[event] onPrivacyManagerAction\', arguments);\n                    deleteCookie(COOKIES.CONSENT_SETTINGS);\n                },\n                onPMCancel: function () {\n                    // console.log(\'[event] onPMCancel\', arguments);\n                },\n                onMessageReceiveData: function () {\n                    // console.log(\'[event] onMessageReceiveData\', arguments);\n                },\n                onSPPMObjectReady: function () {\n                    // console.log(\'[event] onSPPMObjectReady\', arguments);\n                },\n                onConsentReady: function (messageType) {\n                    // console.log(\'[event] onConsentReady\', arguments);\n                    consentCheck(messageType);\n                },\n                onError: function () {\n                    console.error(\'[event] onError\', arguments);\n                },\n            },\n        },\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ4MTIuanMiLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5T0E7QUFhQTs7Ozs7O0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekdBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUdBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZm9sZDMtZnJvbnRlbmQvLi9zcmMvdHMvc2hhcmVkL2VudW1zL2Nvb2tpZXMuZW51bS50cz8zZWExIiwid2VicGFjazovL2ZvbGQzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Iiwid2VicGFjazovL2ZvbGQzLWZyb250ZW5kLy4vc3JjL3RzL3NoYXJlZC9saWIvY2xpZW50Q29va2llcy50cz8zMGQyIiwid2VicGFjazovL2ZvbGQzLWZyb250ZW5kLy4vc3JjL3RzL3NoYXJlZC9saWIvY29va2llLWNvbnNlbnQvc291cmNlcG9pbnQudHM/MDFiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBlbnVtIENPT0tJRVMge1xuXHRTRVNTSU9OID0gJ3Nlc3MnLFxuXHRDSEFOR0VfUFdEID0gJ2YzX2NoYW5nZV9wd2QnLFxuXHRJSUQgPSAnbGFzdElpZCcsXG5cdFNJRCA9ICdsYXN0U2lkJyxcblx0WElEID0gJ2xhc3RYaWQnLFxuXHRPSUQgPSAnbGFzdE9pZCcsXG5cdEdDTElEID0gJ2djbGlkJyxcblx0RlJFRV9BQ0NFU1MgPSAnZmF0Jyxcblx0UFJPUVVFU1QgPSAncHFkJyxcblx0UFJPUVVFU1RfTE9HSU4gPSAncHF1Jyxcblx0UFFfU0VBUkNIID0gJ3BxU2VhcmNoSWQnLFxuXHRBRE9QVElPTl9WQUxVRSA9ICdmM2F2Jyxcblx0TEFTVF9MT0dJTiA9ICdmM2xsJyxcblx0REVOWV9QVUIgPSAnZjNfZGVueV9wdWInLFxuXHRQQVJUTkVSX1RPS0VOID0gJ2YzX3BhcnRuZXJfdG9rZW4nLFxuXHRERU5ZX1VSTCA9ICdmM19kZW55X3VybCcsXG5cdEdSQVBISUNfS0VZID0gJ2YzX3Nob3dfZ3JhcGhpY19pbWFnZXMnLFxuXHRDT01NSVNTSU9OX0pVTkNUSU9OID0gJ2NqX2FmZmlsaWF0ZV9pZCcsXG5cdExJTktfU0hBUkUgPSAnc2l0ZUlEJyxcblx0Q09OU0VOVF9TRVRUSU5HUyA9ICdmM19jb25zZW50X3NldHRpbmdzJyxcblx0RldSX1NFU1NJT04gPSAnRndyVWQnLFxuXHRGV1JfUkVESVJFQ1QgPSAnZjNfRndyUmVkaXJlY3QnLFxuXHRMQU5HVUFHRSA9ICdmM19sYW5ndWFnZScsXG5cdENIT09TRV9ET01BSU4gPSAnZjNfY2hvb3NlX2RvbWFpbicsXG5cdENBUFRDSEEgPSAnZjNfY2FwdGNoYScsXG5cblx0LyogVEVTVElORyAqL1xuXHRURVNUSU5HID0gJ2YzX3Rlc3RpbmcnLFxuXHRVU0VSX0VYUElSQVRJT04gPSAnZjNfdXNlcl9leHBpcmF0aW9uJyxcblx0SU5TVF9FWFBJUkFUSU9OID0gJ2YzX2luc3RfZXhwaXJhdGlvbicsXG5cdFBST1ZJREVSID0gJ2YzX3Rlc3RpbmdfcHJvdmlkZXInLFxuXHRURVNUX0lQID0gJ2YzX3Rlc3RpbmdfaXAnLFxuXHRURVNUX0NPVU5UUllfQ09ERSA9ICdmM190ZXN0aW5nX2NvdW50cnknLFxuXHRDQU1QQUlHTl9URVNUID0gJ2NhbXBfdHQnLFxufVxuXG5leHBvcnQgY29uc3QgaXNUcnVzdGVkQ29va2llID0gKGtleTogc3RyaW5nKSA9PiB7XG5cdHN3aXRjaCAoa2V5KSB7XG5cdFx0Y2FzZSBDT09LSUVTLlNFU1NJT046XG5cdFx0Y2FzZSBDT09LSUVTLkNIQU5HRV9QV0Q6XG5cdFx0Y2FzZSBDT09LSUVTLklJRDpcblx0XHRjYXNlIENPT0tJRVMuU0lEOlxuXHRcdGNhc2UgQ09PS0lFUy5YSUQ6XG5cdFx0Y2FzZSBDT09LSUVTLk9JRDpcblx0XHRjYXNlIENPT0tJRVMuR0NMSUQ6XG5cdFx0Y2FzZSBDT09LSUVTLkZSRUVfQUNDRVNTOlxuXHRcdGNhc2UgQ09PS0lFUy5QUk9RVUVTVDpcblx0XHRjYXNlIENPT0tJRVMuUFJPUVVFU1RfTE9HSU46XG5cdFx0Y2FzZSBDT09LSUVTLkFET1BUSU9OX1ZBTFVFOlxuXHRcdGNhc2UgQ09PS0lFUy5MQVNUX0xPR0lOOlxuXHRcdGNhc2UgQ09PS0lFUy5ERU5ZX1BVQjpcblx0XHRjYXNlIENPT0tJRVMuQ0FQVENIQTpcblx0XHRjYXNlIENPT0tJRVMuTEFOR1VBR0U6XG5cdFx0Y2FzZSBDT09LSUVTLkNIT09TRV9ET01BSU46XG5cdFx0Y2FzZSBDT09LSUVTLkNPTlNFTlRfU0VUVElOR1M6XG5cblx0XHRcdC8qIFRFU1RJTkcgKi9cblx0XHRjYXNlIENPT0tJRVMuVEVTVElORzpcblx0XHRjYXNlIENPT0tJRVMuVVNFUl9FWFBJUkFUSU9OOlxuXHRcdGNhc2UgQ09PS0lFUy5JTlNUX0VYUElSQVRJT046XG5cdFx0Y2FzZSBDT09LSUVTLlRFU1RfSVA6XG5cdFx0Y2FzZSBDT09LSUVTLlRFU1RfQ09VTlRSWV9DT0RFOlxuXHRcdGNhc2UgQ09PS0lFUy5DQU1QQUlHTl9URVNUOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuZXhwb3J0IGNvbnN0IGlzTmVjZXNzYXJ5Q29va2llID0gKG5hbWU6IHN0cmluZykgPT4ge1xuXHRzd2l0Y2ggKG5hbWUpIHtcblx0XHRjYXNlIENPT0tJRVMuQ0hBTkdFX1BXRDpcblx0XHRjYXNlIENPT0tJRVMuUEFSVE5FUl9UT0tFTjpcblx0XHRjYXNlIENPT0tJRVMuTEFTVF9MT0dJTjpcblx0XHRjYXNlIENPT0tJRVMuUFJPUVVFU1Q6XG5cdFx0Y2FzZSBDT09LSUVTLlBST1FVRVNUX0xPR0lOOlxuXHRcdGNhc2UgQ09PS0lFUy5QUV9TRUFSQ0g6XG5cdFx0Y2FzZSBDT09LSUVTLlNFU1NJT046XG5cdFx0Y2FzZSBDT09LSUVTLkxBTkdVQUdFOlxuXHRcdGNhc2UgQ09PS0lFUy5DSE9PU0VfRE9NQUlOOlxuXHRcdGNhc2UgQ09PS0lFUy5DT05TRU5UX1NFVFRJTkdTOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuZXhwb3J0IGNvbnN0IENPTlNFTlRfQ09PS0lFUyA9IFtDT09LSUVTLkNPTlNFTlRfU0VUVElOR1MsICdfc3BfZW5hYmxlX2RmcF9wZXJzb25hbGl6ZWRfYWRzJywgJ2NvbnNlbnRVVUlEJywgJ2V1Y29uc2VudC12MicsICdjY3BhVVVJRCcsICdkbnNEaXNwbGF5ZWQnLCAnY2NwYUFwcGxpZXMnLCAnc2lnbmVkTHNwYScsICdfc3Bfc3UnLCAnY29uc2VudERhdGUnXTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIiwiaW1wb3J0IHsgQ09PS0lFUywgaXNOZWNlc3NhcnlDb29raWUgfSBmcm9tICcuLi9lbnVtcy9jb29raWVzLmVudW0nO1xuXG5pbnRlcmZhY2UgQ29va2llT3B0cyBleHRlbmRzIERlbGV0ZUNvb2tpZU9wdHMge1xuXHRleHBpcmVzPzogbnVtYmVyOyAvLyBudW1iZXIgaW4gc2Vjb25kc1xuXHQvKiogZG9lcyBub3QgVVJJIGVuY29kZSB0aGUgY29va2llIHZhbHVlICovXG5cdHJhdz86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBEZWxldGVDb29raWVPcHRzIHtcblx0cGF0aD86IHN0cmluZztcblx0ZG9tYWluPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIHNldCBhIGNvb2tpZSwgd2l0aCBjb252ZW5pZW50IHBhdGgvZG9tYWluIG9wdGlvbnNcbiAqXG4gKiBXQVJOSU5HOiBtdWx0aXBsZSBjb29raWVzIGNhbiBleGlzdCBhdCBkaWZmZXJlbnQgcGF0aHMgYW5kIGRvbWFpbnMuXG4gKiBJZiB5b3UgY3JlYXRlIGEgY29va2llIHdpdGggdGhlIHNhbWUgbmFtZSBhbmQgcGF0aCBhcyBhbm90aGVyLCBib3RoIHdpbGwgZXhpc3RcbiAqIHNpbXVsdGFuZW91c2x5LCBhbmQgdGhlIG9uZSB3aXRoIHRoZSBtb3JlIHNwZWNpZmljIHBhdGgvZG9tYWluIHdpbGwgb3ZlcnJpZGUgdGhlIG90aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29va2llKFxuXHRuYW1lOiBzdHJpbmcsXG5cdHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgPSAnJyxcblx0b3B0czogQ29va2llT3B0cyA9IHt9XG4pIHtcblx0aWYgKGFsbG93ZWRUb1NldENvb2tpZShuYW1lKSkge1xuXHRcdGxldCBwYXJhbXM6IHN0cmluZ1tdID0gW107XG5cblx0XHQvKlxuXHRcdCAqIG5vdGU6IHRoaXMgaXMgbm90IHVuaXZlcnNhbCEgIHRoaXMgaXMgaG93IGZvbGQzIHNldHMgaXRzIGNvb2tpZXMuXG5cdFx0ICogSWYgdGhpcyBjb2RlIGdldHMgYm9ycm93ZWQgZm9yIGFub3RoZXIgc2l0ZSwgaXQgbWF5IG5lZWQgYmUgY2hhbmdlZC5cblx0XHQgKi9cblx0XHRjb25zdCBjb29raWVEb21haW4gPSAnLicgKyBsb2NhdGlvbi5ob3N0bmFtZS5zcGxpdCgnLicpLnNsaWNlKC0yKVxuXHRcdFx0LmpvaW4oJy4nKTtcblxuXHRcdGlmICghb3B0cy5yYXcpIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlIGFzIHN0cmluZyk7XG5cdFx0cGFyYW1zLnB1c2gobmFtZSArICc9JyArICh2YWx1ZSB8fCAnJykpO1xuXG5cdFx0aWYgKG9wdHMuZXhwaXJlcykge1xuXHRcdFx0bGV0IGRhdGUgPSBuZXcgRGF0ZShvcHRzLmV4cGlyZXMgPCAwID8gLTEgOiBEYXRlLm5vdygpICsgb3B0cy5leHBpcmVzICogMTAwMCk7XG5cdFx0XHRwYXJhbXMucHVzaCgnZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpKTtcblx0XHR9XG5cblx0XHQvLyBhbGxvdyB1bnNldHRpbmcgKGFzIHdlbGwgYXMgY2hhbmdpbmcpIGRvbWFpbiB1c2luZyBvcHRzLmRvbWFpblxuXHRcdGxldCBkb21haW4gPSBjb29raWVEb21haW47XG5cdFx0aWYgKHR5cGVvZiBvcHRzLmRvbWFpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGRvbWFpbiA9IG9wdHMuZG9tYWluO1xuXHRcdH1cblx0XHRpZiAoZG9tYWluKSB7XG5cdFx0XHRwYXJhbXMucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXHRcdH1cblxuXHRcdHBhcmFtcy5wdXNoKCdwYXRoPScgKyAob3B0cy5wYXRoIHx8ICcvJykpO1xuXG5cdFx0ZG9jdW1lbnQuY29va2llID0gcGFyYW1zLmpvaW4oJzsgJyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZzogc3RyaW5nKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cblxuLyoqXG4gKiBnZXQgYSBjb29raWVcbiAqXG4gKiBXQVJOSU5HOiBtdWx0aXBsZSBjb29raWVzIGNhbiBleGlzdCBhdCBkaWZmZXJlbnQgcGF0aHMgYW5kIGRvbWFpbnMuXG4gKiBPbmx5IHRoZSBtb3N0IHNwZWNpZmljIHdpbGwgYmUgdmlzaWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29va2llKG5hbWU6IHN0cmluZywgcmF3ID0gZmFsc2UpIHtcblx0bGV0IG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefCApJyArIGVzY2FwZVJlZ0V4cChuYW1lKSArICc9KFteO10rKScpKTtcblx0bGV0IGNvb2tpZSA9IG1hdGNoICYmIG1hdGNoWzJdO1xuXHRpZiAoY29va2llICYmICFyYXcpIGNvb2tpZSA9IGRlY29kZVVSSUNvbXBvbmVudChjb29raWUpO1xuXG5cdHJldHVybiBjb29raWU7XG59XG5cbi8qKlxuICogZGVsZXRlIGEgY29va2llLCB3aXRoIGNvbnZlbmllbnQgcGF0aC9kb21haW4gZGVmYXVsdHNcbiAqXG4gKiBXQVJOSU5HOiBUaGlzIHdpbGwgb25seSB3b3JrIGlmIHRoZSBwYXRoIGFuZCBkb21haW4gbWF0Y2ggdGhlIHNldCBjb29raWUhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVDb29raWUobmFtZTogc3RyaW5nLCBvcHRzOiBEZWxldGVDb29raWVPcHRzID0ge30pIHtcblx0c2V0Q29va2llKG5hbWUsICcnLCB7IGV4cGlyZXM6IC0xLCAuLi5vcHRzIH0pO1xufVxuXG5jb25zdCBhbGxvd2VkVG9TZXRDb29raWUgPSAobmFtZTogc3RyaW5nKSA9PiB7XG5cdGlmIChpc05lY2Vzc2FyeUNvb2tpZShuYW1lKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRsZXQgY29uc2VudFNldHRpbmdzID0gSlNPTi5wYXJzZShnZXRDb29raWUoQ09PS0lFUy5DT05TRU5UX1NFVFRJTkdTKSk7XG5cdFx0aWYgKGNvbnNlbnRTZXR0aW5ncy5nZHByLmFwcGxpZXMgPT09IHRydWUpIHtcblx0XHRcdGlmIChjb25zZW50U2V0dGluZ3MuZ2Rwci5zb3VyY2UgPT09ICdzb3VyY2Vwb2ludCcpIHtcblx0XHRcdFx0cmV0dXJuIGNvbnNlbnRTZXR0aW5ncy5nZHByLmNvbnNlbnRlZFZlbmRvcnMuaW5jbHVkZXMoJ0FuY2VzdHJ5Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIEJlIG9uIHRoZSBzYWZlIHNpZGUgaWYgc291cmNlcG9pbnQgaGFzbid0IHZlcmlmaWVkIGNvbnNlbnQgYW5kIGdkcHIgYXBwbGllc1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0gY2F0Y2goZSkge1xuXHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG4iLCIvKiBCcmllZiBpbnRybyB0byBhbGwgb2YgdGhpcyBjb25mdXNpbmcgc3R1ZmY6XG4gKlxuICogVGhpcyBmaWxlIGlzIGEgd3JhcHBlciBmb3IgU291cmNlcG9pbnQncyBjb25zZW50IG1hbmFnZW1lbnQgcGxhdGZvcm0gKENNUCkuXG4gKiBTb3VyY2Vwb2ludCBpcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgdGhhdCBwcm92aWRlcyBhIHdheSB0byBtYW5hZ2UgY29uc2VudCBmb3IgY29va2llcyBhbmQgdHJhY2tpbmcuXG4gKiBUaGUgQ01QIGlzIHVzZWQgdG8gbWFuYWdlIGNvbnNlbnQgZm9yIGNvb2tpZXMgYW5kIHRyYWNraW5nLlxuICogVGhlIENNUCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcGxheWluZyBhIGNvbnNlbnQgZGlhbG9nIHRvIHRoZSB1c2VyLiBUaGUgdXNlciBjYW4gdGhlbiBjaG9vc2UgdG8gYWNjZXB0IG9yIHJlamVjdCBjb29raWVzIGFuZCB0cmFja2luZy4gVGhlIENNUCB0aGVuIHNldHMgYSBjb29raWUgd2l0aCB0aGUgdXNlcidzIGNvbnNlbnQgc2V0dGluZ3MuXG4gKiBBbnl0aGluZyBpbiB0aGlzIHNjcmlwdCByZWZlcnJpbmcgdG8gdXNuYXQgaXMgZm9yIHRoZSBVUyBOYXRpb25hbCBQcml2YWN5IExhdywgd2hpY2ggaXMgYSBkaWZmZXJlbnQgc2V0IG9mIGxhd3MgdGhhbiB0aGUgR0RQUi5cbiAqIEluIG9yZGVyIHRvIGFkaGVyZSB0byB0aGUgdXNuYXQsIHdlIGFyZSB1c2luZyBncHAgKEdsb2JhbCBQcml2YWN5IFBsYXRmb3JtKSB0byBtYW5hZ2UgY29uc2VudCBmb3IgdGhlIFVTIE5hdGlvbmFsIFByaXZhY3kgTGF3LlxuICogQW55dGhpbmcgaW4gdGhpcyBzY3JpcHQgdGhhdCBpcyByZWZlcnJpbmcgdG8gdGNmIGlzIGZvciBhZGhlcmluZyB0byB0aGUgR0RQUiBsYXdzIGZvciBFdXJvcGUuXG4gKlxuICogV2UgYXJlIGNhbGxpbmcgX3RjZmFwaSgnYWRkRXZlbnRMaXN0ZW5lcicpIHRvIGtub3cgd2hldGhlciBnZHByIGFwcGxpZXMgZm9yIHRoaXMgdXNlci5cbiAqIFdlIGFyZSBjYWxsaW5nIF90Y2ZhcGkoJ2dldEN1c3RvbVZlbmRvckNvbnNlbnRzJykgdG8gZ2V0IHRoZSB1c2VyJ3MgY29uc2VudCBzZXR0aW5ncyBmb3IgdGhlIEdEUFIuXG4qL1xuXG5pbXBvcnQgeyBDb25zZW50U2V0dGluZ3MgfSBmcm9tICcuLi8uLi9kdG8vZjMtdHlwZXMnO1xuaW1wb3J0IHsgQ09PS0lFUyB9IGZyb20gJy4uLy4uL2VudW1zL2Nvb2tpZXMuZW51bSc7XG5pbXBvcnQgeyBkZWxldGVDb29raWUsIGdldENvb2tpZSwgc2V0Q29va2llIH0gZnJvbSAnLi4vY2xpZW50Q29va2llcyc7XG5pbXBvcnQgeyBEYXRhTGF5ZXJPYmogfSBmcm9tICcuLi9nb29nbGVBbmFseXRpY3NFdmVudHMnO1xuXG5kZWNsYXJlIGNvbnN0IHdpbmRvdzogYW55O1xuZGVjbGFyZSBjb25zdCBkYXRhTGF5ZXI6IHtcblx0cHVzaChvYmo6IERhdGFMYXllck9iaik6IHZvaWQ7XG59O1xuXG5kZWNsYXJlIGNvbnN0IF9fdGNmYXBpOiBhbnk7XG5cbihmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gc2VuZE5vbkdEUFJQYWdldmlld0V2ZW50KCkge1xuXHRcdHRyeSB7XG5cdFx0XHR3aW5kb3cuZGF0YUxheWVyID0gd2luZG93LmRhdGFMYXllciB8fCBbXTtcblx0XHRcdGRhdGFMYXllci5wdXNoKHtcblx0XHRcdFx0ZXZlbnQ6ICdub25fZ2Rwcl9wYWdldmlldycsXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2hvd0dEUFJQcml2YWN5TGluaygpIHtcblx0XHR0cnkge1xuXHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dkcHJfbGlua19kaXNwbGF5Jykuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjb25zZW50Q2hlY2soZXZlbnRUeXBlOiBzdHJpbmcpIHtcblx0XHRsZXQgc2V0dGluZ3M6IENvbnNlbnRTZXR0aW5ncyA9IHtcblx0XHRcdGdkcHI6IHt9IGFzIGFueSxcblx0XHR9IGFzIENvbnNlbnRTZXR0aW5ncztcblxuXHRcdGlmIChldmVudFR5cGUgPT09ICdnZHByJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c2V0dGluZ3MgPSBKU09OLnBhcnNlKGdldENvb2tpZShDT09LSUVTLkNPTlNFTlRfU0VUVElOR1MpKTtcblx0XHRcdH0gY2F0Y2goZSkgeyBjb25zb2xlLmVycm9yKGUpOyB9XG5cblx0XHRcdGlmIChzZXR0aW5ncz8uZ2Rwcj8uc291cmNlID09PSAnc291cmNlcG9pbnQnKSB7XG5cdFx0XHRcdC8qIFdlIGtub3cgdGhhdCBzb3VyY2Vwb2ludCBoYXMgdG9sZCB1cyB3aGV0aGVyIGdkcHIgYXBwbGllcyBmb3IgdGhpcyB1c2VyLiBOb3RoaW5nIGxlZnQgdG8gZG8gKi9cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9fdGNmYXBpKCdhZGRFdmVudExpc3RlbmVyJywgMiwgKHRjRGF0YTogYW55LCBzdWNjZXNzOiBib29sZWFuKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRcdHNldHRpbmdzLmdkcHIuYXBwbGllcyA9IHRjRGF0YS5nZHByQXBwbGllcztcblx0XHRcdFx0XHRcdHNldHRpbmdzLmdkcHIuc291cmNlID0gJ3NvdXJjZXBvaW50JzsgLy8gc291cmNlcG9pbnQgaGFzIHRvbGQgdXMgdGhhdCBnZHByIGFwcGxpZXMgZm9yIHRoaXMgdXNlclxuXG5cdFx0XHRcdFx0XHRpZiAoc2V0dGluZ3MuZ2Rwci5hcHBsaWVzKSB7XG5cdFx0XHRcdFx0XHRcdF9fdGNmYXBpKFxuXHRcdFx0XHRcdFx0XHRcdCdnZXRDdXN0b21WZW5kb3JDb25zZW50cycsXG5cdFx0XHRcdFx0XHRcdFx0Mixcblx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbih2ZW5kb3JDb25zZW50czogYW55LCBzdWNjZXNzOiBhbnkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZlbmRvcnMgPSB2ZW5kb3JDb25zZW50cy5jb25zZW50ZWRWZW5kb3JzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCgoeDogYW55KSA9PiB4Lm5hbWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmZpbHRlcigoeDogYW55KSA9PiB4ID09PSAnQW5jZXN0cnknKTsgLy8gRm9yIG5vdywgd2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBBbmNlc3RyeS4gQWRkIG1vcmUgdmVuZG9ycyBhcyBuZWVkZWQuXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3MuZ2Rwci5jb25zZW50ZWRWZW5kb3JzID0gdmVuZG9ycztcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ2dldEN1c3RvbVZlbmRvckNvbnNlbnRzIGZhaWxlZC4nKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBnZXQgdGNEYXRhJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2V0Q29va2llKENPT0tJRVMuQ09OU0VOVF9TRVRUSU5HUywgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRpbmdzLmdkcHIuYXBwbGllcykge1xuXHRcdFx0c2hvd0dEUFJQcml2YWN5TGluaygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZW5kTm9uR0RQUlBhZ2V2aWV3RXZlbnQoKTtcblx0XHR9XG5cdH1cblxuXHR3aW5kb3cuX3NwX3F1ZXVlID0gW107XG5cdHdpbmRvdy5fc3BfID0ge1xuXHRcdGNvbmZpZzoge1xuXHRcdFx0YWNjb3VudElkOiAxNzI2LFxuXHRcdFx0cHJvcGVydHlIcmVmOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuXHRcdFx0YmFzZUVuZHBvaW50OiAnaHR0cHM6Ly9jZG4ucHJpdmFjeS1tZ210LmNvbScsXG5cdFx0XHRnZHByOiB7fSxcblx0XHRcdHVzbmF0OiB7XG5cdFx0XHRcdGluY2x1ZGVzVXNwQXBpOiB0cnVlLFxuXHRcdFx0fSxcblx0XHRcdGNvbnNlbnRMYW5ndWFnZTogd2luZG93LkYzLnBhZ2UubGFuZ3VhZ2UsXG5cdFx0XHRjdXN0b206IHt9LFxuXHRcdFx0ZXZlbnRzOiB7XG5cdFx0XHRcdG9uTWVzc2FnZUNob2ljZVNlbGVjdCgpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnW2V2ZW50XSBvbk1lc3NhZ2VDaG9pY2VTZWxlY3QnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdGRlbGV0ZUNvb2tpZShDT09LSUVTLkNPTlNFTlRfU0VUVElOR1MpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvbk1lc3NhZ2VSZWFkeSgpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnW2V2ZW50XSBvbk1lc3NhZ2VSZWFkeScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9uTWVzc2FnZUNob2ljZUVycm9yKCkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdbZXZlbnRdIG9uTWVzc2FnZUNob2ljZUVycm9yJywgYXJndW1lbnRzKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b25Qcml2YWN5TWFuYWdlckFjdGlvbigpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnW2V2ZW50XSBvblByaXZhY3lNYW5hZ2VyQWN0aW9uJywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRkZWxldGVDb29raWUoQ09PS0lFUy5DT05TRU5UX1NFVFRJTkdTKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b25QTUNhbmNlbCgpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnW2V2ZW50XSBvblBNQ2FuY2VsJywgYXJndW1lbnRzKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b25NZXNzYWdlUmVjZWl2ZURhdGEoKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1tldmVudF0gb25NZXNzYWdlUmVjZWl2ZURhdGEnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvblNQUE1PYmplY3RSZWFkeSgpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnW2V2ZW50XSBvblNQUE1PYmplY3RSZWFkeScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9uQ29uc2VudFJlYWR5KG1lc3NhZ2VUeXBlOiAnZ2RwcicgfCAndXNuYXQnIHwgJ2NjcGEnKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1tldmVudF0gb25Db25zZW50UmVhZHknLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdGNvbnNlbnRDaGVjayhtZXNzYWdlVHlwZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9uRXJyb3IoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignW2V2ZW50XSBvbkVycm9yJywgYXJndW1lbnRzKTtcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0fSxcblx0fTtcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24812\n')}},__webpack_exports__={};__webpack_modules__[24812]()})();